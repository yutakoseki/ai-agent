# 基本方針
- すべての応答は日本語で行うこと。
- あらかじめdocs配下のドキュメントを参照し、ドキュメントに沿った開発をおこなうこと。
- ドキュメントがない場合は、ドキュメントを作成、更新すること。
- 変更は最小限かつ意図を明確にし、不要な差分を避けること。
- 既存のユーザー変更は決して巻き戻さないこと。

# ツールとパス
- コマンドやツールのパス指定は可能な限り絶対パスを用いること。
- 破壊的コマンド（`git reset --hard`、`git checkout --` など）は使用しないこと。
- 編集には `apply_patch` など安全な手段を優先すること。
- パッケージ管理は pnpm を使用すること。npm や yarn は使用しないこと。

# コード編集の姿勢
- 既存のスタイル・命名規則・ファイル構造を尊重すること。
- 変更理由が分かりにくい箇所のみ、簡潔なコメントを追加する（冗長な説明は禁止）。
- 自動生成ファイルやロックファイルは必要時のみ更新し、無関係な更新を避けること。
- 外部依存を追加する場合は理由を明示し、最小限に抑えること。

# セキュリティ・プライバシー
- テナント分離や認可に関わる設定を変更する際は、影響範囲を必ず確認し明記すること。
- 機密情報（鍵・トークン・個人情報）を書き込まないこと。見つけた場合は伏せて報告すること。
- ログや出力に不要な機密情報を含めないこと。
- 監査ログはアプリログと分離し、耐改ざん性のあるストレージ/専用テーブルを利用すること（WORM 相当を推奨）。

# レビューと品質
- 変更後は関連箇所の簡易確認（lint/format/testなど）を推奨し、実行の有無を報告すること。
- テストを追加・修正する場合は、対象機能と意図を短く記述すること。
- 影響範囲が広い場合は段階的なPR/コミットを推奨すること。
- 改修後は関連テスト（少なくとも変更箇所の単体/疎通テスト）を実行し、結果を報告すること。実行できない場合は理由を明記すること。
- 機能追加やバグ修正では、可能な限りテストコード（ユニット/コンポーネント/疎通）を追加・更新し、カバレッジを維持・向上させること。

# UX・ドキュメント
- 手順や設定を追記する際は、再現手順を箇条書きで簡潔に書くこと。
- ユーザー向けの文言や表示は日本語で、短く分かりやすくすること。

# 技術要件
- マルチテナントと権限
  - `tenant_id` で厳密分離（DBはRLS推奨、ストレージはプレフィックス分離）。
  - RBAC: Admin/Manager/Member 等で操作を制限。write系は原則承認フロー挿入を許可。
  - エンタイトルメント: tenant×agent で利用可否・回数上限を管理し、プラン(Basic/Proなど)で初期値を定義。

- データソース/モデル/監査
  - コネクタ: Drive/Box/Notion/Calendar/Slack などは read/write/notify スコープを明示し、writeは最小権限。
  - モデル利用: センシティブ情報はプライベートエンドポイント/社内モデル優先。外部LLM時はマスキング/フィルタ。
  - 監査ログ: 各エージェント実行の入力/出力/承認/エラーを記録し、PIIはマスキングまたはハッシュ化。
  - レート/クォータ: プラン別月次Quotaと tenant×agent の上限を設け、実行前チェック。
  - 可観測性: トレースID・ジョブIDをログ/UIに表示し原因特定を容易にする。

- アプリ/フロントエンド
  - Next.js (App Router) + TypeScript。環境変数は型付きで管理し公開/非公開境界を遵守。
  - API: Route Handler/BFFでテナントIDとRBACをミドルウェア検証。
  - API Route Handler の `handleError` はラベル付きで呼ぶ（例: `handleError(error, traceId, "POST /api/users")`。パスパラメータは `:id` 形式）。
  - 状態管理: React Server Componentsを優先しクライアントは最小限。必要に応じ軽量ストアを使用。
  - UI文言と関数コメントは日本語で簡潔に記述する。

# ログ/監査の運用ルール
- ログ出力は構造化 JSON を基本とし、`traceId`/`requestId`/`jobId`/`tenantId`/`userId`/`label` をフィールドで保持する。PII や秘密情報は出力せず、必要な場合はマスク/ハッシュする。
- 監査ログは専用ロガー/ストリームに出力し、アプリログと混在させない。成功/失敗を問わず記録し、保持期間と改ざん耐性を確保する。
- 環境変数: `LOG_LEVEL`（prod/stg は基本 `info`、dev は `debug`）、`LOG_PRETTY`（ローカルのみ true 推奨）、必要に応じ `LOG_SAMPLING_DEBUG`。監査系は `AUDIT_LOG_ENABLED` / `AUDIT_LOG_SINK` を明示する。
- エラーは一度だけログし、スタックはフィールド（例: `error.stack`）へ。`traceId` を必ず付与し、多重ロギングを避ける。
- `console` 直書きは禁止し、共通ロガーを使用する。`handleError` など既存フックもロガー経由に統一する。

- AgentCore / Strands / 実行基盤
  - AgentCore: 入出力スキーマ検証、権限スコープチェック、リトライ/タイムアウト、監査ログを共通実装。
  - Strands: DAG自由化は禁止。制約付き直列/限定分岐のみ許可。入出力マッピングはスキーマ検証し欠損は事前エラー。
  - 実行: エージェントはキュー経由で実行し、ワーカーはテナントスコープで隔離。冪等性キーとリトライポリシーを定義。

- テスト/品質
  - React/NextはコンポーネントテストとAPI疎通テストを用意し、外部コネクタはモックで切り離す。
  - 機能追加/バグ修正ではテストコード（ユニット/コンポーネント/疎通）を可能な限り追加・更新し、カバレッジを維持・向上させる。

- インフラ/デプロイ
  - デプロイ先は Amplify Gen2 を前提とし、環境変数やシークレットはAmplify側の機能で安全に管理する。
  - インフラ構成は Terraform でコード化し、Amplifyや周辺リソースも含めてIaCで管理する。環境ごとにstateを分離し、plan/applyはレビュープロセスを経て実行する。

- リポ構成・CI
  - モノレポを前提とし、`apps/web`(Next.js)、`services/agent-core`(Python)、`packages`(型/SDK/設定スキーマ)、`infra/terraform` に分割する。
  - BFF(Route Handler)で認証/RBAC/テナント検証を終端し、AgentCoreにはテナントスコープ済みの非同期ジョブ/APIのみを渡す。同期呼び出しは最小限。
  - CIは影響範囲ベースで分割し、Node/TSとPythonのジョブを分離。SBOM/脆弱性スキャンを両言語で実施する。
  - 依存管理は Node側: pnpm/Turborepo、Python側: Poetry/uv + Docker化を標準とし、バージョンピンとロックファイルを保持する。
  - セパレートリポに切り替える場合は、仕様・スキーマ・SDKのドリフト防止策（バージョン整合性と自動チェック）を検討する。

# ブランチ運用とコミット
- 基本フローは `feature/*` → `develop` → `staging` → `prod`。`feature` から `staging/prod` への直接マージは禁止。
- ブランチ作成元/命名: 機能は `develop` から `feature/[issue]-[name]`。緊急対応は `prod` から `hotfix/[issue]-[desc]` を切り、`prod` と `develop` 両方へマージしブランチ削除。
- `prod`/`staging`/`develop` は直接 push せず PR 経由でマージする。
- テスト期待値: `feature` は Lint/単体/統合を必須、E2E は `staging/prod` で実行（CI 設定と整合させる）。
- コミットメッセージは Conventional Commits (`feat|fix|docs|refactor|test|chore` 等) に従う。

- 仕様・ドキュメント
  - 機能単位で仕様書を作成し、目的・前提・入出力・エッジケース・権限/RBAC・監査要件を簡潔に記載する。
  - 同時にパラメーターシートを作成し、API/環境変数/コネクタ設定/エージェント別スコープなどを一覧化する。更新時は仕様書とパラメーターシートを同期させる。

- セキュリティ留意事項
  - 基本分離と権限
    - テナント分離: DBはRLS、ストレージ/キャッシュ/キューもテナントスコープを分離。
    - 最小権限: コネクタスコープは read/write/notify を明示し、write系は分離したエージェントに限定。
    - 秘匿情報: 鍵/トークン/PIIをログ・コードに残さず、環境変数/シークレットマネージャで管理し平文コミット禁止。
  - 監査と運用
    - 監査ログ: 入出力/承認/失敗を記録し、PIIはマスキングorハッシュ。トレースID/ジョブID付与。
    - モデル利用: 外部LLMは機密をマスキングし、可能なら社内モデル/プライベートエンドポイントを優先。
    - 変更管理/パッチ: セキュリティ/品質パッチのリードタイムを定義し、承認・ロールバック・影響評価と事前通知を行う。
  - ネットワークとアプリ
    - ネットワーク: 管理系エンドポイントはIP制限＋Auth、CORS/CSRFを適切に設定。WAF/IDS/DDoS対策を検討。
    - アプリセキュリティ: SQLi防止（プレースホルダ/ORM）、動的SQLは許可リスト＋レビュー、DB最小権限と監査ログ、SAST/DAST/ペンテ頻度、SBOM/CVE対応リードタイム。
    - セッション/Cookie: Secure/HttpOnly/SameSite方針、セッション再発行とタイムアウト、CSRF、ロックアウト/レート制限、ブラウザ保存禁止。
    - Web一般: XSS対策（エンコード/CSP）、ファイルアップロード制限（拡張子/MIME/AV/隔離）、HSTS/TLS/証明書更新方針。
  - データ保護とライフサイクル
    - 暗号化: 転送(TLS)＋保存時暗号化、KMS/HSMと鍵ローテ、BYOK可否を明示。
    - マルチテナント分離: 論理分離の仕組みと他社アクセス防止策を定義。機密/PIIはマスキングし、運用者閲覧を制限。
    - データ終了時: 返却形式、削除期限、削除証明の有無を定義。漏えい時の報告/補償手順を明記。
    - バックアップ: 対象範囲・頻度・保持期間・保管場所・復元手順を明確化。
  - SLA/監視/BCP
    - SLA/可用性: 稼働率目標、計画停止通知、RTO/RPOを定義し公開。
    - 監視: OS/リソース/ミドル/ジョブ/ネットワークを監視し、検知時の通知経路を決める。
    - 物理/BCP: DC所在地、冗長化、DR/BCP手順を確認し、メンテナンスの事前アナウンスを行う。
  - 法令・ガバナンス
    - 準拠法/個人情報/国外移転の扱いを明示し、生成AIの学習データ取扱方針を定義。

# 例外対応
- 不明点やリスクがある場合は、推測で進めずユーザーに確認を求めること。
- 予期しない差分や競合を検知した場合は即座に報告し、指示を仰ぐこと。
