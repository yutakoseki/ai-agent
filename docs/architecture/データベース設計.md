# DynamoDB 設計 (マルチテナント/RLS 相当)

## 目的

- RLS がない DynamoDB でテナント分離を担保するキー設計とアプリ側ガードを定義する。
- Terraform で IaC 管理し、環境ごとの差分・権限を明示する。
- ローカル/CI では DynamoDB Local で再現可能にする。

## 設計原則

- すべてのパーティションキーに `tenantId` を含める（物理分離度を高める）。
- テナント外アクセスはアプリ層で拒否し、DynamoDB には `ConditionExpression` で PK を固定して二重防御。
- コアデータはシングルテーブルで集約し、ライフサイクル/スループットが大きく異なるもの（ログ/アーカイブなど）は例外的に分離する。

## テーブルレイアウト（シングルテーブル）

- テーブル名例: `aiagent-app`
- PK: `PK = TENANT#<tenantId>`
- SK: 種別 + 識別子でプレフィックス
  - テナント: `SK = TENANT#<tenantId>`
  - ユーザー: `SK = USER#<userId>`
  - エージェント: `SK = AGENT#<agentId>`
  - 実行履歴: `SK = EXEC#<executionId>`
  - 監査ログ: `SK = AUDIT#<timestamp>#<uuid>`
- GSI 例
  - `GSI1`（種別横断検索）: `GSI1PK = SK_PREFIX`（例: `USER`, `AGENT`）, `GSI1SK = PK` or `createdAt`
  - `GSI2`（ユーザー逆引きが必要な場合）: `GSI2PK = USER#<userId>`, `GSI2SK = TENANT#<tenantId>`
- TTL: セッション/一時トークン系アイテムに付与（例: `expiresAt` を TTL 属性に設定）。
- 暗号化: KMS デフォルト有効化。
- バックアップ: PITR 有効化。

### アイテム例

- テナント
  - `PK=TENANT#t1`, `SK=TENANT#t1`, `name`, `plan`, `enabled`
- ユーザー
  - `PK=TENANT#t1`, `SK=USER#u1`, `email`, `role`, `name`, `createdAt`
- 実行履歴
  - `PK=TENANT#t1`, `SK=EXEC#exec1`, `agentId`, `status`, `traceId`, `inputSummary`, `createdAt`
- 監査（軽量イベント）
  - `PK=TENANT#t1`, `SK=AUDIT#2024-01-01T00:00:00Z#uuid`, `action`, `resource`, `actorUserId`, `traceId`
  - 大量/長期保持が前提なら後述のログ専用テーブルへ退避

### アクセスパターンとクエリ

- テナント内ユーザー一覧: `Query PK=TENANT#<tenantId>`, `begins_with(SK,'USER#')`
- 実行履歴一覧: `Query PK=TENANT#<tenantId>`, `begins_with(SK,'EXEC#')`
- 監査ログ: 上記に加え期間絞り（`SK BETWEEN AUDIT#ts1 AND AUDIT#ts2`）
- テナント逆引き（必要なら）: `GSI2PK=USER#<userId>` で所属テナントを取得

### シングルテーブルの例外（ログ/長期保持）

- 分離を検討する条件
  - 書き込み頻度が高くホットパーティション化しやすい。
  - 保持期間・TTL がコアデータと大きく異なる。
  - スキャンやバッチ集計が主用途で GSI 設計を共有しづらい。
- 推奨構成（例: `aiagent-log`）
  - PK: `PK=TENANT#<tenantId>`
  - SK: `SK=LOG#<timestamp>#<uuid>`（または `AUDIT#...` プレフィックス）
  - GSI1（トレース/実行単位の相関）: `GSI1PK=TRACE#<traceId>`, `GSI1SK=<timestamp>`
  - TTL: ログ保持期間に合わせて設定（例: 30〜90 日）
  - 暗号化/KMS, PITR は本番は有効化（コストと要件に応じて調整）

### 一貫性と同時実行制御

- 作成/更新時は `ConditionExpression` で `attribute_not_exists(PK)` / 楽観ロック用の `version` を併用。
- テナントチェックをアプリ層で実施した上で、DynamoDB 側も `PK = TENANT#<tenantId>` を固定して二重防御。

## ローカル/CI 運用

- DynamoDB Local を docker-compose で起動し、テーブル作成＋シードスクリプトを実行。
  ```bash
  docker compose -f docker-compose.dynamodb.yml up -d
  DYNAMODB_ENDPOINT=http://localhost:8000 pnpm exec node packages/db-dynamo/scripts/seed.mjs
  ```
- Vitest 統合テストは Local に接続する設定（`NODE_ENV=test` 時は `http://localhost:8000` へフォールバック）で実行。

## IaC とデプロイ方針

- **リソースは Amplify の自動生成を使わず Terraform で作成**する。理由:
  - 環境差分と権限をコードで明示し、ブランチやワークスペースで管理できる。
  - Amplify プロジェクト外からも再利用しやすい（将来他のワーカー/バッチが増えても同じテーブルを参照可能）。
- Terraform で定義するもの:
  - DynamoDB テーブル (PK/SK/GSI/TTL/PITR/KMS)
  - IAM ロール/ポリシー（Amplify の実行ロールにテーブルへのアクセス権を付与）
  - 環境別 state/backends, workspace, tags

## Amplify Gen2 との権限

- Amplify 側で自動作成されたテーブルは **使わず**、Terraform 管理のテーブルを参照する。
- Amplify のアプリロール（またはブランチ/バックエンド環境ロール）に対し、Terraform で発行した IAM ポリシーをアタッチすればアクセス可能。
  - Next.js (SSR/Route Handler) はそのロールの権限で `@aws-sdk/client-dynamodb` を呼ぶ。
  - 必要な環境変数（テーブル名、リージョン、エンドポイント）を Amplify 環境変数に設定。
- これにより「Amplify 自動権限」には依存せず、最小権限ポリシーをコードで管理できる。

## 今後の実装タスク（抜粋）

1. Terraform に DynamoDB テーブル/GSI/TTL/PITR/KMS を追加 (`infra/terraform/dynamodb/*.tf`)。
2. Amplify 実行ロールに付与する IAM ポリシーを Terraform で定義（最小権限: テーブル単位の read/write + describe）。
3. `packages/db-dynamo`（新規）で DocumentClient ラッパとテナントスコープ付き CRUD を実装。
4. API ルートをモックから DynamoDB 実体に置き換え（リポジトリ層経由）。
5. DynamoDB Local 用の docker-compose とシードスクリプトを追加し、Vitest 統合テストを Local 実行に切り替え。

### ローカル/CI 手順メモ

- ローカル起動: `docker compose -f docker-compose.dynamodb.yml up -d`
- シード: `DYNAMODB_ENDPOINT=http://localhost:8000 pnpm exec node packages/db-dynamo/scripts/seed.mjs`
- テスト環境用変数例:
  - `DYNAMODB_ENDPOINT=http://localhost:8000`
  - `DYNAMODB_TABLE_NAME=aiagent-dev`
  - `AWS_REGION=ap-northeast-1`
  - `AWS_ACCESS_KEY_ID=local` / `AWS_SECRET_ACCESS_KEY=local`（Local 用ダミー）
  - `NODE_ENV=test`（テスト時にローカルエンドポイントへ自動フォールバック）
